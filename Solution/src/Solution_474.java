import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @auth Nannf
 * @date 2020/10/1 15:58
 * @description: 在计算机界中，我们总是追求用有限的资源获取最大的收益。
 * <p>
 * 现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。
 * <p>
 * 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。
 * <p>
 * <p>
 * 输入: strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
 * 输出: 4
 * 解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。
 * <p>
 * <p>
 * 输入: strs = ["10", "0", "1"], m = 1, n = 1
 * 输出: 2
 * 解释: 你可以拼出 "10"，但之后就没有剩余数字了。更好的选择是拼出 "0" 和 "1" 。
 * <p>
 * <p>
 * ["10","0001","111001","1","0"]
 * 3
 * 4
 * <p>
 * ["10","0001","111001","1","0"]
 * 4
 * 3
 * <p>
 * ["11111","100","1101","1101","11000"]
 * 5
 * 7
 * <p>
 * ["0","1101","01","00111","1","10010","0","0","00","1","11","0011"]
 * 63
 * 36
 * <p>
 * ["0","11","1000","01","0","101","1","1","1","0","0","0","0","1","0","0110101","0","11",
 * "01","00","01111","0011","1","1000","0","11101","1","0","10","0111"]
 * 9
 * 80
 * <p>
 * ["011","1","11","0","010","1","10","1","1","0","0","0","01111","011","11","00",
 * "11","10","1","0","0","0","0","101","001110","1","0","1","0","0","10","00100",
 * "0","10","1","1","1","011","11","11","10","10","0000","01","1","10","0"]
 * 44
 * 39
 */
public class Solution_474 {

    public static void main(String[] args) throws Exception {
        String[] strs = {"011", "1", "11", "0", "010", "1", "10", "1", "1", "0", "0", "0", "01111", "011", "11", "00", "11", "10", "1", "0", "0", "0", "0", "101", "001110", "1", "0", "1", "0", "0", "10", "00100", "0", "10", "1", "1", "1", "011", "11", "11", "10", "10", "0000", "01", "1", "10", "0"};
        System.out.println(new Solution_474().findMaxForm(strs, 44, 39));
    }

    public int findMaxForm(String[] strs, int m, int n) {
        int ans = 0;
        // 昨天使用递归的方式实现了背包的问题的解法
        // 今天尝试使用动态规划的角度来对背包问题进行解答
        // 动态规划的思路时：
        // 把问题的解决分为很多个阶段，每个阶段可以有不同的选择，每种的选择之后会对应不同的状态
        // 然后把状态进行合并，在这个题目中的状态就是剩余的0和1的个数，所以每层最多的状态数就是n*m

        // 我们据此定义了状态数组
        // 分别表示每次做一个选择之后，对应的m和n的状态
        // 下一个我们就需要明白两件事
        // 1. 如何由已知的状态推到出新的状态
        // 2. 如何合并每一层的重复状态
        int[][][] dp = new int[strs.length][m + 1][n + 1];

        for (int i = 0; i < strs.length; i++) {
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= n; k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        // 先计算第一个元素选不选的状态
        int[] numCount = countZeroAndOne(strs[0]);
        // 不选的状态
        dp[0][m][n] = 0;
        // 选择的状态
        dp[0][m - numCount[0]][n - numCount[1]] = 1;
        // 这个动态转移方程要怎么想呢？
        for (int i = 1; i < strs.length; i++) {
            int[] numInfo = countZeroAndOne(strs[i]);
            for (int j = 0; j < m; j++) {
                for (int k = 0; k < n; k++) {
                    // 第一个判断条件表示是从上一个状态迁移而来
                    if (dp[i - 1][j][k] == 1 && j >= numInfo[0] && k >= numInfo[1]) {
                        // 当满足条件的时候我们可以选或者不选
                        // 这两种情况分别对应了一种情况，但是选不选是跟数组后面的元素是相关的
                        // 不满足无后效性这一特征
                        // 我想起了之前做的一个地下城与勇士的题目，这种有后效性的题目需要由后往前逆推。
                    }
                }
            }
        }


        return ans;
    }

    public int findMaxForm_dfs(String[] strs, int m, int n) {
        // 我们定义子问题 一定是因为我们发现了重复计算的部分，
        // 而不是凭感觉就定义一个东西，然后碰运气
        // 如果要明白重复计算的部分，就需要直到回溯的全过程
        // 画出递归的运行图
        // 找到重复计算的部分
        // 0-1背包的重复原因是因为有一些同样重量的物品是挨着的，这就导致了重复问题的出现
        // <modify> 这边说的其实并不完全对，只能说到达某一个点时的状态可能由多种情况转移而来，并不一定需要重复的数据的出现
        // 这就意味着，如果只选择他们其中一个的话，选择谁都后面的影响都是一致的，也就是这两个只需要计算一个
        // 当这个重复的数字有很多的时候 也是一样的
        // 也就是无论选择这些重复数字中的谁，到后面不重复的位置而言，都是一样的，
        // 所以这个重复的状态就是在某个位置上，如果剩余的m和n是一样的，就是重复计算
        // 根据这个我们定义了一个三维数组
        int[][][] memo = new int[strs.length + 1][m + 1][n + 1];
        backtrace(strs, m, n, 0, memo);
        return memo[0][m][n];
    }

    private int backtrace(String[] strs, int m, int n, int s, int[][][] memo) {
//        System.out.println(trace);
        // 在进行计算之前，我们要判断当前的数据有没有被计算过
        // 这边有个问题就是计算过就应该被跳过吗？
        // 我觉得不是把，举个简单的例子，就是如果一个是是100个1，然后它后面跟了100个单独的1
        // 对这101个数后面的数而言，选择100个1 的数还是选择100个单独的1的数跟他的数量都是一致的
        // 为啥要直接跳过呢？
        // 我好像是个脑瘫
        // 这个函数是有返回的
        if (memo[s][m][n] != 0) {
            return memo[s][m][n];
        }

        // 接下来是关于结束状态的定义 如果数组中所有的元素都已经过滤完成，直接结束
        if (s == strs.length) {
            return 0;
        }

        // 先计算出如果要选择当前索引，需要多少0和1
        int[] numInfo = countZeroAndOne(strs[s]);
        if (m >= numInfo[0] && n >= numInfo[1]) {
            memo[s][m][n] = Math.max(backtrace(strs, m - numInfo[0], n - numInfo[1], s + 1, memo) + 1,
                    backtrace(strs, m, n, s + 1, memo));
        } else {
            // 这边不满足的时候，当前状况下的值等于下一个状态的值
            memo[s][m][n] = backtrace(strs, m, n, s + 1, memo);
        }
        return memo[s][m][n];
    }

    private int[] countZeroAndOne(String str) {
        int[] cnt = new int[2];
        for (char c : str.toCharArray()) {
            cnt[c - '0']++;
        }
        return cnt;
    }
}
