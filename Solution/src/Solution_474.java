import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @auth Nannf
 * @date 2020/10/1 15:58
 * @description: 在计算机界中，我们总是追求用有限的资源获取最大的收益。
 * <p>
 * 现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。
 * <p>
 * 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。
 * <p>
 * <p>
 * 输入: strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
 * 输出: 4
 * 解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。
 * <p>
 * <p>
 * 输入: strs = ["10", "0", "1"], m = 1, n = 1
 * 输出: 2
 * 解释: 你可以拼出 "10"，但之后就没有剩余数字了。更好的选择是拼出 "0" 和 "1" 。
 * <p>
 * <p>
 * ["10","0001","111001","1","0"]
 * 3
 * 4
 * <p>
 * ["10","0001","111001","1","0"]
 * 4
 * 3
 * <p>
 * ["11111","100","1101","1101","11000"]
 * 5
 * 7
 * <p>
 * ["0","1101","01","00111","1","10010","0","0","00","1","11","0011"]
 * 63
 * 36
 * <p>
 * ["0","11","1000","01","0","101","1","1","1","0","0","0","0","1","0","0110101","0","11",
 * "01","00","01111","0011","1","1000","0","11101","1","0","10","0111"]
 * 9
 * 80
 * <p>
 * ["011","1","11","0","010","1","10","1","1","0","0","0","01111","011","11","00",
 * "11","10","1","0","0","0","0","101","001110","1","0","1","0","0","10","00100",
 * "0","10","1","1","1","011","11","11","10","10","0000","01","1","10","0"]
 * 44
 * 39
 */
public class Solution_474 {

    public static void main(String[] args) throws Exception {
        String[] strs = {"10", "0", "1"};
        System.out.println(new Solution_474().findMaxForm(strs, 1, 1));
    }

    public int findMaxForm(String[] strs, int m, int n) {
        int ans = 0;
        // 关于这个状态数组的定义，今天看到一句话
        // 题目问什么我们就怎么定义
        // 假设给定的字符串数组的长度是k,0和1的个数分别是m，n
        // 拿题目要求的就是 使用m个0和n个1在[0,k-1]上最多能选择几个字符串出来
        // 那么我们就定义状态数组如下dp[i][j][k]在[0,i]上使用j个0和k个1能选择多少字符串出来
        int[][][] dp = new int[strs.length + 1][m + 1][n + 1];

        // 定义完状态之后就需要去找动态转移方程，就是如何由前一个状态推导出后一个状态
        // 对一个状态dp[i][j][k]而言，它的最大值是多少呢，我们要明白这个问题，就需要先知道
        // 这个j和k是怎么来的，最开始的状态是dp[0][0][0]=0;
        // dp[1][]
        for (int i = 0; i <= strs.length; i++) {
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= n; k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        // 初始化数组，这个使用哨兵优化
        dp[0][0][0] = 0;

        // 这个动态转移方程要怎么想呢？
        for (int i = 1; i <= strs.length; i++) {
            int[] numInfo = countZeroAndOne(strs[i - 1]);
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= n; k++) {
                    // 这个状态不等于-1表示这个状态是之前的状态迁移过来的
                    if (dp[i - 1][j][k] != -1) {
                        // 如果迁移的这个状态剩余的0和1还够当前的元素使用
                        if ((m - j) >= numInfo[0] && (n - k) >= numInfo[1]) {
                            // 这边会对应两个状态
                            // 一个是不选的状态
                            // 这个时候 这个状态就跟上一个一致
                            dp[i][j][k] = dp[i - 1][j][k];

                            // 还有一个就是选的状态，选的状态需要把坐标移动，并把上一个状态的值+1
                            dp[i][j + numInfo[0]][k + numInfo[1]] = dp[i - 1][j][k] + 1;
                        } else {
                            // 如果不够了，那当前元素对应的字符串的数量只能跟上一个一致
                            dp[i][j][k] = dp[i - 1][j][k];
                        }

                    }
                }
            }
        }
        for (int i =0;i<=m;i++) {
            for (int j =0; j<=n;j++) {
                ans = Math.max(ans,dp[strs.length][i][j]);
            }
        }
        return ans;
    }

    public int findMaxForm_dfs(String[] strs, int m, int n) {
        // 我们定义子问题 一定是因为我们发现了重复计算的部分，
        // 而不是凭感觉就定义一个东西，然后碰运气
        // 如果要明白重复计算的部分，就需要直到回溯的全过程
        // 画出递归的运行图
        // 找到重复计算的部分
        // 0-1背包的重复原因是因为有一些同样重量的物品是挨着的，这就导致了重复问题的出现
        // <modify> 这边说的其实并不完全对，只能说到达某一个点时的状态可能由多种情况转移而来，并不一定需要重复的数据的出现
        // 这就意味着，如果只选择他们其中一个的话，选择谁都后面的影响都是一致的，也就是这两个只需要计算一个
        // 当这个重复的数字有很多的时候 也是一样的
        // 也就是无论选择这些重复数字中的谁，到后面不重复的位置而言，都是一样的，
        // 所以这个重复的状态就是在某个位置上，如果剩余的m和n是一样的，就是重复计算
        // 根据这个我们定义了一个三维数组
        int[][][] memo = new int[strs.length + 1][m + 1][n + 1];
        backtrace(strs, m, n, 0, memo);
        return memo[0][m][n];
    }

    private int backtrace(String[] strs, int m, int n, int s, int[][][] memo) {
//        System.out.println(trace);
        // 在进行计算之前，我们要判断当前的数据有没有被计算过
        // 这边有个问题就是计算过就应该被跳过吗？
        // 我觉得不是把，举个简单的例子，就是如果一个是是100个1，然后它后面跟了100个单独的1
        // 对这101个数后面的数而言，选择100个1 的数还是选择100个单独的1的数跟他的数量都是一致的
        // 为啥要直接跳过呢？
        // 我好像是个脑瘫
        // 这个函数是有返回的
        if (memo[s][m][n] != 0) {
            return memo[s][m][n];
        }

        // 接下来是关于结束状态的定义 如果数组中所有的元素都已经过滤完成，直接结束
        if (s == strs.length) {
            return 0;
        }

        // 先计算出如果要选择当前索引，需要多少0和1
        int[] numInfo = countZeroAndOne(strs[s]);
        if (m >= numInfo[0] && n >= numInfo[1]) {
            memo[s][m][n] = Math.max(backtrace(strs, m - numInfo[0], n - numInfo[1], s + 1, memo) + 1,
                    backtrace(strs, m, n, s + 1, memo));
        } else {
            // 这边不满足的时候，当前状况下的值等于下一个状态的值
            memo[s][m][n] = backtrace(strs, m, n, s + 1, memo);
        }
        return memo[s][m][n];
    }

    private int[] countZeroAndOne(String str) {
        int[] cnt = new int[2];
        for (char c : str.toCharArray()) {
            cnt[c - '0']++;
        }
        return cnt;
    }
}
