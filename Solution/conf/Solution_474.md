### 背包问题可以使用记忆化递归的前提
1. 有重复的数据
    - 这里说的重复指的是选择重复数据中的任意一个对状态的影响是一样的
    - 具体而言 以本题为例，假设存在 1,1,01 这样一个序列，我选择第一个1，或者
      第二个1，当我们到达01的时候，都是一样的，假设01后面还有很多值，那么当我们
      递归返回的时候，就不需要重复计算了。
2. 对1的补充
    - 其实在1中说的只是一个会导致重复状态的情况，但是不是唯一的情况
    - 比如有一个数字由10个1组成，后面还跟了10个单独的1，当选择那个10个1的数字，和选了那10个1
      对状态的贡献值都是一样的，这就导致了重复状态的出现，这两种情况只需计算一次。

### 记忆化意味者什么
- 在这道题之前，我都以为记忆化是为了剪枝，也确实如此，但是我们在剪枝的时候，
  需要去考虑，我们如何定义状态，是单纯的标记这个状态已经被处理过无需重复处理，
  直接跳过就行，还是需要为每个状态记录一个状态值，之前我理解的记忆化是全部跳过，
  忽略了计算过的情况也是可以有状态的。

### 计算字符串中0，1数量的优化
-  之前的计算方式是：
   ```java
   char[] chars = str.toCharArray();
   int oneCount = 0;
   for (int i = 0; i< chars.length;i++) {
       if (Integer.parseInt(String.valueOf(chars[i])) == 1) {
           oneCount++;
       }
   }
   return oneCount;
   ```
   这种的计算问题就是会不停的拆箱，装箱，因为dfs的时间复杂度是指数级别的，这个操作的重复次数会非常的高，
   导致耗时非常大，会直接导致dfs的实现因为超过时间限制无法通过测试用例。
   
### 动态规划的思路
#### 递归的问题
- 时间复杂度高
  * 如果我们不用记忆化递归，假设由数组的长度是n，不考虑特殊情况下，每个数组中的元素都有选和不选两个选择，
  这就导致了时间的复杂度是2^n
- 空间复杂度高
  * 递归涉及到不停的出栈入栈，具体的空间复杂度的计算这里先略过不谈。
  
#### 动态规划的解决思路
1. 背包问题的动态规划求解思路
   - 背包问题的定义是袋子中最多能装多重的物品
   - 这道题不同的是，在袋子中装不超过限制的最重的物品后，物品的数量是多少
      * 这就导致了一个问题，就是之前通用的背包的思路没有保存一共装了多少个
      * 如何在每个阶段做完选择之后记录下哪种选择是选了的结果，哪种是没选的结果
2. 记录下我的初步解题思路
   ```java
   // 昨天使用递归的方式实现了背包的问题的解法
           // 今天尝试使用动态规划的角度来对背包问题进行解答
           // 动态规划的思路时：
           // 把问题的解决分为很多个阶段，每个阶段可以有不同的选择，每种的选择之后会对应不同的状态
           // 然后把状态进行合并，在这个题目中的状态就是剩余的0和1的个数，所以每层最多的状态数就是n*m
   
           // 我们据此定义了状态数组
           // 分别表示每次做一个选择之后，对应的m和n的状态
           // 下一个我们就需要明白两件事
           // 1. 如何由已知的状态推到出新的状态
           // 2. 如何合并每一层的重复状态
           int[][][] dp = new int[strs.length][m + 1][n + 1];
           // 先计算第一个元素选不选的状态
           int[] numCount = countZeroAndOne(strs[0]);
           // 不选的状态
           dp[0][m][n] = 1;
           // 选择的状态
           dp[0][m - numCount[0]][n - numCount[1]] = 1;
           // 这个动态转移方程要怎么想呢？
           for (int i = 1; i < strs.length; i++) {
               int[] numInfo = countZeroAndOne(strs[i]);
               for (int j = 0; j < m; j++) {
                   for (int k = 0; k < n; k++) {
                       // 第一个判断条件表示是从上一个状态迁移而来
                       if (dp[i - 1][j][k] == 1 && j >= numInfo[0] && k >= numInfo[1]) {
                           // 当满足条件的时候我们可以选或者不选
                           // 这两种情况分别对应了一种情况，但是选不选是跟数组后面的元素是相关的
                           // 不满足无后效性这一特征
                           // 我想起了之前做的一个地下城与勇士的题目，这种有后效性的题目需要由后往前逆推。
                       }
                   }
               }
           }
   ```