### 背包问题可以使用记忆化递归的前提
1. 有重复的数据
    - 这里说的重复指的是选择重复数据中的任意一个对状态的影响是一样的
    - 具体而言 以本题为例，假设存在 1,1,01 这样一个序列，我选择第一个1，或者
      第二个1，当我们到达01的时候，都是一样的，假设01后面还有很多值，那么当我们
      递归返回的时候，就不需要重复计算了。

### 记忆化意味者什么
- 在这道题之前，我都以为记忆化是为了剪枝，也确实如此，但是我们在剪枝的时候，
  需要去考虑，我们如何定义状态，是单纯的标记这个状态已经被处理过无需重复处理，
  直接跳过就行，还是需要为每个状态记录一个状态值，之前我理解的记忆化是全部跳过，
  忽略了计算过的情况也是可以有状态的。

### 计算字符串中0，1数量的优化
- 之前我是把String转换成字符数组，然后使用Integer.parseInt(String.valueOf(chars[i]))
   来进行计算，每次需要算两次，然后每次计算的时候需要不停的拆箱，装箱，因为这个递归的复杂度
   是指数的，拆箱装箱特别损耗性能，这导致了超时的问题发生，这个其实在两年前多线程的时候，
   就出现过这个问题，但是我现在仍然再犯，下次切记。
   