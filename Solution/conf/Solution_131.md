如何获取一个字符串的所有子串

和把字符串拆分成不同的子串列表

是两个问题，我们今天讨论的是第二个问题，把一个字符串拆分成由其子串组合而成的数组

例如：给定的字符串 aab

转换成三个集合

["a","a","b"]

["aa","b"]

["a","ab"]

现在我们就是要求。

我一开始的思路是按照子串的最大长度的大小由[1,n-1]之间逐个遍历

确实可以把结果按照这个来进行划分，但是我在实际写代码的时候，发现没办法继续写了。

拿abcde来举例子

当我们 子串的长度是2的时候，我们要如何来控制呢

首先我们遍历到a，a可不可以当成一个单独的子串呢？ 是可以的 因为1<=2 ，此时我们就发现一个问题，按照这个逻辑，后面的每个字符都可以当成一个合法的子串，那此时我们就发现，虽然我们在处理2这个长度的，但是把1的又重新遍历了一遍。

依次类推，我们遍历三的时候，又会把1和2的重新遍历一遍。

所以这个思路是行不通的。

其实，只要我们的子串长度不到n，都是合法的。

而且我们截取过一段之后，后续的截取和之前的逻辑是一模一样的，只是规模变小了，这个好像可以是用递归来解决。

但是这个递归的函数我们要怎么定义呢? 递归的结束条件又是啥，如何缩小问题的规模，这些问题紧跟着就来了

我们发现这其实就是一个对字符的拆分问题。

拆分需要知道一个起始的位置，第一次从0开始，然后长度从1到n，每次截取过之后，会生成一个新的位置，然后从这个位置开始截取。

直到位置的下标已经超过了字符串的长度。

```java
// 我们这样定义一个递归函数
void backtrace(int startIndex, String srcString, List<String> trace, List<List<String> result) {
    
}
```





